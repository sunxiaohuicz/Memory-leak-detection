%!TEX root = bare_conf.tex
\section{Related Work}\label{sec:related}
This section mainly discusses three aspects of research: Research on static approaches to memory leaks, research on complex programs analysis and research on the application of projection method.
\subsection{Static Approaches on Memory Leaks}
%The common static detetcion approaches~\cite{YZ04} include type inference\footnote{Type inference. https://en.wikipedia.org/wiki/Type\_inference. 2017.}, rule-based inspection~\cite{SJP05}, and symbolic execution followed by constraint solving. However, all these approaches have limitations when dealing with large scale programs. Type inference automatically derives the type of variables by tools, this approach is suitable for analyzing large scale programs, but it is not applicable to the control flow analysis. Regarding rule-based inspection, its scalability is poor due to that describing a program into rules is complicated and error-prone. For symbolic execution, the number of paths will increase exponentially with the increase of the program size, which leads to problems such as ``path-explosion" and ``infinite-search-space", and thus increases the time complexity of entire detection. Comparing to the above approaches, CFG based approach simplifies paths and thus avoids the ``path-explosion" during symbolic execution. 

In recent years, some researchers proposed new static approaches to memory leak detection. \cite{XZX11},~\cite{XZX15}, ~\cite{HL06} and ~\cite{YXYR14} detected errors by model checking. \cite{XZX11},~\cite{XZX15} proposed Memory State Transition Graph (MSTG) and implemented the tool Melton. MSTG recorded change of memory-object states as path conditions. It made the cases in the same code pattens were easy to detect~\cite{HL06} considered from the perspective of object ownership for memory mangement and modeling it. The ownership-model approach could check potential memory leaks and double deletions in a procedure. However, the above approaches may cause high false positive in large programs. In some sense, according to the leak model in conplex control flows, our approach checks memory leaks based on this model. It makes the detection in complex programs simple and intuitive. 
 
\cite{DWC12} and~\cite{XR08} detected memory leaks by memory-object abstraction.~\cite{DWC12} presented heap memory abstract method for heap-manipulating programs. This approach showed its good scalability in large C programs.~\cite{XR08} focused on the abstraction of memory objects and their relationships. It showed a high precision for checking leaks, but its Efficiency needed to be improved. Besides, ~\cite{LXL15} detected memory leaks effectively based on the executable formal semantics of C source code, while the coverage of flaws were limited to the three cases. LeakChecker~\cite{YXYR14} detected the leaks in loop effectively. Our approach takes the complexity of large programs into account, and ensure the accuracy and low run-time overhead.

%We also survey the static detection tools particularly for memory leaks detection. Noted that one tool may adopt multiple approaches. We highlight some well-known tools as follows. One of them is Prefix~\cite{BPS00}, which is embedded in the Visual Studio. Prefix detects memory leaks by symbolic simulation. It is path-sensitive and uses function summaries for scalability. However, Prefix explores one path at a time, which becomes inefficient when procedures have many paths. %Heuristics limit the search to a small set of paths. 
%Some other tools show a high analysis accuracy by using different techniques. For instance, Splint and CppCheck use the rule-based approach, where Splint mainly analyzes style and annotations of program, and CppCheck detects errors by matching expressions. As an example of flow-sensitive approach, tool Cqual\footnote{Cqual. http://www.cs.umd.edu/~jfoster/cqual/. 2004.} uses type inference and constraint solving techniques for improve accuracy. These tools essentially check the potential memory leaks by adding annotations for the access operation in the source programs. This approach has high preciseness, however, it will generate many false positives as the complexity of the program increases, because the annotations added cannot be reused. Tool RL\_Detector detects resource leaks in C programs. It improves detection efficiency by constructing resource behavior to streamline slices, this method retains all statements that are allocated and deallocated of resources, as well as the statements that affect the use of the resource (including memory). Our tool is based on~\cite{XA05}, and combines approaches such as symbolic execution, which are used in the above tools as well. Compared with existing work, our tool is specific for detecting memory leaks in C programs, especially in the program with complex control flows. 
\subsection{Complex Programs Analysis}
%\subsection{Regarding the Complex Control Flow Concept}
%There are few studies on complex control flow in the field of static analysis. As in~\cite{KJMP06}, this concept is mainly used in the process of dynamic testing to predict some frequently executed paths, in order to eliminate false positive caused by the evaluating the conditional branches. In~\cite{KK12}, the concept is only used to show a method to measure the complexity of programs, which is irrelevant to memory detection. %in complex control flows. 
Research on the analysis complex programs mainly focus on control flow graphs. To our knowledge, there is currently no investigation of memory leak detection in complex control flow.~\cite{KJMP06} and~\cite{KFM13} study control flow graphs. The DMP (diverge-merge processor) in~\cite{KJMP06} is a processor architecture to predict complex branches dynamically.~\cite{KFM13} presents a method to calculate all the worst paths from any node. There are other studies on complex object-oriented programs like~\cite{LLQ16, MGDD14}. Specifically, the research object of~\cite{LLQ16} are complex path conditions, and the research object of~\cite{MGDD14} are inheritance and friend functions in object-oriented languages.~\cite{KK12} shows a method to measure the complexity of programs. This paper combines complex control flow with memory leaks in the program, shows a novel detecting method.
\subsection{The Application of Projection Method}
%In the field of program analysis, especially in the detection of program dynamic memory leaks, the researchers are more inclined to adopt the dynamic memory modeling methods. For example, \cite{KK16} builds a heap abstraction model that restrains the heap model by combining multiple abstraction positions into a summary position, however in practical applications, there is still a great gap on accuracy between the results of this method and the exact results. \cite{WJG14} builds a pointer behavior model, this model utilizes model checking tools to verify the reachability of assertions to analyzing memory leaks. \cite{MFS12} builds a bounded model, where the memory leaks properties are added. This method transforms the memory leaks problem into solving satisfiability problem, thereby achieves the memory leaks detection. However, this detection scheme needs to reduce the generated verification space and accordingly improve the accuracy of verify. Our approach builds a program model, which is used to be traversed and stored into the stack following some rules for detecting memory leaks.
Recently, the idea of projection is often applied to computer vision~\cite{DG14, HWS15}, mathematical model selection~\cite{NL10} and other related research fields due to its close relationship with graphs. There are only a few of papers use the projection method in the program analysis. \cite{D94} analyzed the specification and abortion of programs by the projection of functions. While in terms of safety, this paper only takes a conservative analysis, in other words, the output is ``uncertain” or ``unknown” for some uncertain input, which is relatively fuzzy, so the accuracy of the analysis results need to be improved. In our approach, we redefine the projection of the program control flow graphs, and solve safety problems with a specific algorithm for detecting memory leaks.
